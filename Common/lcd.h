
#ifdef LCD_PREDEFINED_PINS
#define PIN_LCD_SCE   3
#define PIN_LCD_RESET 4
#define PIN_LCD_DC    6

// SPI bus pins
#define PIN_SSEL  10
#define PIN_SDIN  11
#define PIN_SDOU  12
#define PIN_SCLK  13

#ifdef SPI
#define SPITRANSFER(data) { while (!(SPSR & (1<<SPIF))); SPDR = data; }
#define SPIINDATA SPDR
#else
#define SPITRANSFER(data)   shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data)
#define SPIINDATA 0
#endif

#endif

class LCD
{
public:
	enum
	{
		XM=84,
		YM=48
	};

	static void Fill(byte pattern, int count)
	{  
		digitalWrite(PIN_LCD_SCE, LOW);
		while(count-->0)
		{
			SPITRANSFER(pattern);
		}
		digitalWrite(PIN_LCD_SCE, HIGH);
	}

	static void Clear()
	{  
		Fill(0, XM * YM / 8);
	}


	static void Char(byte character)
	{
		static const byte ASCII[][5] =
		{
		 {0x00, 0x00, 0x00, 0x00, 0x00} // 20  
		,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
		,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
		,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
		,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
		,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
		,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
		,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
		,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
		,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
		,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
		,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
		,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
		,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
		,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
		,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
		,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
		,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
		,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
		,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
		,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
		,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
		,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
		,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
		,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
		,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
		,{0x00, 0x36, 0x36, 0x00, 0x00} // 3a :
		,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
		,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
		,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
		,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
		,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
		,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
		,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
		,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
		,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
		,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
		,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
		,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
		,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
		,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
		,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
		,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
		,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
		,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
		,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
		,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
		,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
		,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
		,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
		,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
		,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
		,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
		,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
		,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
		,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
		,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
		,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
		,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
		,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
		,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c ¥
		,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
		,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
		,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
		,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
		,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
		,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
		,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
		,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
		,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
		,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
		,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
		,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
		,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
		,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j 
		,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
		,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
		,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
		,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
		,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
		,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
		,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
		,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
		,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
		,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
		,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
		,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
		,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
		,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
		,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
		,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
		,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
		,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
		,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
		,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e ?
		,{0x78, 0x46, 0x41, 0x46, 0x78} // 7f ?
		,{0xff, 0x81, 0x81, 0x81, 0xff} // 80 frame
		,{0x18, 0x24, 0x42, 0x24, 0x18} // 81 diamont
		};
		
	  digitalWrite(PIN_LCD_SCE, LOW);
	  if( character < 0x20 || character-0x20 >= sizeof(ASCII)/5 )
	  {
	    for (byte index = 5+2; index > 0 ; index--)
	    {
	      SPITRANSFER(character);
	    } 
	  }
	  else
	  {
	    SPITRANSFER(0x00);
	    for (byte index = 0; index < 5; index++)
	    {
	      byte data = ASCII[character - 0x20][index];
	      SPITRANSFER(data);    
	    }
	    SPITRANSFER(0x00);
	  }
	  digitalWrite(PIN_LCD_SCE, HIGH);
	}

	static void Init(void)
	{
		pinMode(PIN_LCD_SCE, OUTPUT);
		pinMode(PIN_LCD_DC, OUTPUT);
		digitalWrite(PIN_LCD_DC,HIGH);
		digitalWrite(PIN_LCD_SCE,HIGH);
		#ifdef PIN_LCD_RESET		
		pinMode(PIN_LCD_RESET, OUTPUT);
		digitalWrite(PIN_LCD_RESET, LOW);
		digitalWrite(PIN_LCD_RESET, HIGH);
		delay(10);  
		#endif
		#if 1
		Cmd( 0x21 );  // LCD Extended Commands.
		Cmd( 0xC8 );  // Set LCD Vop (Contrast).
		Cmd( 0x06 );  // Set Temp coefficent.
		Cmd( 0x13 );  // LCD bias mode 1:48.
		#endif
		Cmd( 0x20 );  // LCD Standard Commands, Horizontal addressing mode.
		Cmd( 0x0C );  // LCD in normal mode.
	//  Cmd( 0x0D );  // LCD in reverse mode
	}

	static void Goto(byte row,byte col)
	{
		digitalWrite(PIN_LCD_DC, LOW);
		digitalWrite(PIN_LCD_SCE, LOW);
		SPITRANSFER(0x40|row); //Cmd(0x40|row);
		SPITRANSFER(0x80|col); // Cmd(0x80|col);	  
		digitalWrite(PIN_LCD_SCE, HIGH);
		digitalWrite(PIN_LCD_DC, HIGH);		
	}

	static void Str(char *characters)
	{
		while (*characters)
		{
			Char(*characters++);
		}
	}

	template<unsigned base>
	static void Num(unsigned num,char digits=0)
	{
	  unsigned div = 1;
	  // find biggest power of base that is not greater then num 
	  // keep going when more digits are requested
	  while( true )
	  {
	    unsigned newdiv = div*base;
	    if( newdiv < div ) break; // overflow
	    digits--;
	    if( newdiv > num && digits<=0) break; // end
	    div = newdiv;
	  }
	  while( div > 0 )
	  {
	    unsigned dig = num / div;
	    char c = dig < 10 ? '0'+dig : 'A'+dig-10;
	    Char(c);
	    num-=dig*div;
	    div/=base;      
	  }
	}

	template<unsigned base>
	static void Num(int num,char digits)
	{
	  if( num<0 ) 
	  {
	    Char('-');
	    num=-num;
	    digits--;
	  }
	  Num<base>((unsigned)num,digits);
	}

private:
	static void Cmd(byte cmd)
	{
	  digitalWrite(PIN_LCD_DC, LOW);
	  digitalWrite(PIN_LCD_SCE, LOW);
	  SPITRANSFER(cmd);
	  digitalWrite(PIN_LCD_SCE, HIGH);
	  digitalWrite(PIN_LCD_DC, HIGH);
	}
};
